{"mappings":"A,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,E,Q,C,I,E,E,S,E,S,I,E,E,SGEO,MAAM,EAAa,CACxB,EAAG,IAAI,EAAA,OAAM,CAAE,EAAG,EAAG,GACrB,EAAG,IAAI,EAAA,OAAM,CAAE,EAAG,EAAG,GACrB,EAAG,IAAI,EAAA,OAAM,CAAE,EAAG,EAAG,EACvB,CAGgB,CAAA,EAAW,CAAC,CAAa,EAAW,CAAC,CAAK,EAAW,CAAC,CACtD,EAAW,CAAC,CAAa,EAAW,CAAC,CAAK,EAAW,CAAC,CACtD,EAAW,CAAC,CAAa,EAAW,CAAC,CAAK,EAAW,CAAC,C,I,G,E,S,E,S,E","sources":["<anon>","src/index.ts","src/frame.ts","src/axes.ts","src/scatterplot.ts","src/plot.ts","src/vectorplot.ts","src/data.ts"],"sourcesContent":["\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire9513\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire9513\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nconst $06989a4a8159123e$export$60bbd10bdffb2e81 = {\n    i: new (0, $ilwiq.Vector3)(1, 0, 0),\n    j: new (0, $ilwiq.Vector3)(0, 1, 0),\n    k: new (0, $ilwiq.Vector3)(0, 0, 1)\n};\nconst $06989a4a8159123e$export$bb7594b552f278d7 = {\n    xy: {\n        normal: $06989a4a8159123e$export$60bbd10bdffb2e81.k,\n        unit: {\n            x: $06989a4a8159123e$export$60bbd10bdffb2e81.i,\n            y: $06989a4a8159123e$export$60bbd10bdffb2e81.j\n        }\n    },\n    xz: {\n        normal: $06989a4a8159123e$export$60bbd10bdffb2e81.j,\n        unit: {\n            x: $06989a4a8159123e$export$60bbd10bdffb2e81.i,\n            z: $06989a4a8159123e$export$60bbd10bdffb2e81.k\n        }\n    },\n    yz: {\n        normal: $06989a4a8159123e$export$60bbd10bdffb2e81.i,\n        unit: {\n            y: $06989a4a8159123e$export$60bbd10bdffb2e81.j,\n            z: $06989a4a8159123e$export$60bbd10bdffb2e81.k\n        }\n    }\n};\nclass $06989a4a8159123e$var$Axis extends (0, $ilwiq.ArrowHelper) {\n    constructor(direction, length){\n        super(direction, new (0, $ilwiq.Vector3)(0, 0, 0), length);\n    }\n}\nclass $06989a4a8159123e$export$387a78ab20784494 {\n    constructor(lengthX, lengthY, lengthZ){\n        this.lengthX = lengthX;\n        this.lengthY = lengthY;\n        this.lengthZ = lengthZ;\n        this.x = new $06989a4a8159123e$var$Axis(new (0, $ilwiq.Vector3)(1, 0, 0), this.lengthX * 1.1);\n        this.y = new $06989a4a8159123e$var$Axis(new (0, $ilwiq.Vector3)(0, 1, 0), this.lengthY * 1.1);\n        this.z = new $06989a4a8159123e$var$Axis(new (0, $ilwiq.Vector3)(0, 0, 1), this.lengthZ * 1.1);\n        this.setGrids();\n    }\n    setGrids() {\n        this.gridXZ = new (0, $ilwiq.GridHelper)(Math.max(this.lengthX, this.lengthZ));\n        this.gridXZ.position.setX(this.lengthX / 2);\n        this.gridXZ.position.setZ(this.lengthZ / 2);\n        this.gridXY = new (0, $ilwiq.GridHelper)(Math.max(this.lengthX, this.lengthY));\n        this.gridXY.position.setX(this.lengthX / 2);\n        this.gridXY.position.setY(this.lengthY / 2);\n        this.gridXY.rotateOnAxis(new (0, $ilwiq.Vector3)(1, 0, 0), Math.PI / 2);\n        this.gridYZ = new (0, $ilwiq.GridHelper)(Math.max(this.lengthY, this.lengthZ));\n        this.gridYZ.position.setY(this.lengthY / 2);\n        this.gridYZ.position.setZ(this.lengthZ / 2);\n        this.gridYZ.rotateOnAxis(new (0, $ilwiq.Vector3)(0, 0, 1), Math.PI / 2);\n    }\n}\n\n\nclass $f5cd7ec90b5fdafd$export$b89a827e9254211a extends (0, $ilwiq.Scene) {\n    // TODO: at the moment only one size bc grid can only be squared\n    // look into this for solution https://discourse.threejs.org/t/rectangular-gridhelper-possibility/37812\n    constructor(canvas, size = 10){\n        super();\n        this.canvas = canvas;\n        this.size = size;\n        this.observer = new ResizeObserver(()=>this.update());\n        this.scene = new (0, $ilwiq.Scene)();\n        this.scene.background = new (0, $ilwiq.Color)(0xffffff);\n        const { clientWidth: clientWidth, clientHeight: clientHeight } = canvas;\n        this.renderer = new (0, $ilwiq.WebGLRenderer)({\n            canvas: canvas\n        });\n        this.renderer.setSize(clientWidth, clientHeight);\n        this.setCamera(clientWidth, clientHeight);\n        this.setControls();\n        this.setAxes();\n        this.updateOnChanges();\n        this.update();\n    }\n    setCamera(width, height) {\n        this.camera = new (0, $ilwiq.PerspectiveCamera)(45, width / height, 0.1, 1000);\n        this.camera.position.set(this.size * 2, this.size * 2, this.size * 2);\n        this.scene.add(this.camera);\n    }\n    setControls() {\n        this.controls = new (0, $5Rd1x.OrbitControls)(this.camera, this.canvas);\n        this.controls.target.set(0, 0, 0);\n    }\n    setAxes() {\n        this.axes = new (0, $06989a4a8159123e$export$387a78ab20784494)(this.size, this.size, this.size);\n        this.scene.add(this.axes.x);\n        this.scene.add(this.axes.y);\n        this.scene.add(this.axes.z);\n        this.scene.add(this.axes.gridXY);\n        this.scene.add(this.axes.gridXZ);\n        this.scene.add(this.axes.gridYZ);\n    }\n    updateOnChanges() {\n        this.controls.addEventListener(\"change\", ()=>this.update());\n        this.observer.observe(this.canvas);\n    }\n    update() {\n        this.renderer.render(this.scene, this.camera);\n    }\n    capture() {\n        const base64 = this.canvas.toDataURL(\"img/png\");\n    }\n    addPlot(plot) {\n        this.scene.add(...plot.getFrameable());\n        this.update();\n    }\n}\n\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $fc905a1390663dee$export$c78ca4d5ae878870 {\n}\n\n\nclass $a0c7c0ee0c5f7a27$export$eec270bd176da5f5 extends (0, $fc905a1390663dee$export$c78ca4d5ae878870) {\n    constructor(points, pointRadius = 0.2){\n        super();\n        this.points = points.map((v)=>{\n            const geometry = new (0, $ilwiq.SphereGeometry)(pointRadius);\n            const material = new (0, $ilwiq.MeshBasicMaterial)({\n                color: 0x00ff00\n            });\n            const obj = new (0, $ilwiq.Mesh)(geometry, material);\n            obj.position.set(v.x, v.y, v.z);\n            return obj;\n        });\n    }\n    getFrameable() {\n        return this.points;\n    }\n}\n\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\n\nclass $8d22bec9ee525254$export$cb49ab3f965133d4 extends (0, $fc905a1390663dee$export$c78ca4d5ae878870) {\n    constructor(origin, target){\n        super();\n        this.origin = origin;\n        this.target = target;\n        this.drawables = [];\n        this.drawables.push(this.createVector(origin, target));\n        this.drawables.push(...this.createProjection(\"xy\"));\n        this.drawables.push(...this.createProjection(\"yz\"));\n        this.drawables.push(...this.createProjection(\"xz\"));\n        this.drawables.push(this.createAngleToProjection(\"xz\"));\n        this.drawables.push(this.createAngleToProjection(\"xy\"));\n        this.drawables.push(this.createAngleToProjection(\"yz\"));\n        this.drawables.push(this.createAngleToTarget(\"y\"));\n    }\n    createVector(origin, target) {\n        const length = Math.abs(origin.distanceTo(target));\n        return new (0, $ilwiq.ArrowHelper)(target.clone().normalize(), origin, length, 0x000000, length * 0.2, length * 0.1);\n    }\n    createAngleToProjection(planeIdx) {\n        const plane = (0, $06989a4a8159123e$export$bb7594b552f278d7)[planeIdx];\n        const planeNormal = plane.normal;\n        const projectedVector = this.target.clone().projectOnPlane(planeNormal);\n        const radius = projectedVector.distanceTo(this.origin) * 0.5;\n        let initialRotation = 0;\n        let angleToProjection = projectedVector.angleTo((0, $06989a4a8159123e$export$60bbd10bdffb2e81).i);\n        if (planeIdx === \"xz\") {\n            initialRotation = -Math.PI / 2;\n            angleToProjection = projectedVector.angleTo((0, $06989a4a8159123e$export$60bbd10bdffb2e81).k);\n        }\n        if (planeIdx === \"yz\") {\n            initialRotation = Math.PI / 2;\n            angleToProjection = projectedVector.angleTo((0, $06989a4a8159123e$export$60bbd10bdffb2e81).j);\n        }\n        const curve = new (0, $ilwiq.EllipseCurve)(this.origin.x, this.origin.y, radius, radius, 0, angleToProjection, false, initialRotation);\n        const material = new (0, $ilwiq.LineBasicMaterial)({\n            color: 0x000000\n        });\n        const geometry = new (0, $ilwiq.BufferGeometry)().setFromPoints(curve.getPoints(50));\n        const rotation = new (0, $ilwiq.Quaternion)().setFromUnitVectors((0, $06989a4a8159123e$export$60bbd10bdffb2e81).k, plane.normal);\n        geometry.applyQuaternion(rotation);\n        return new (0, $ilwiq.Line)(geometry, material);\n    }\n    createAngleToTarget(axis) {\n        const radius = this.target.clone().distanceTo(this.origin);\n        const projectedVector = this.target.clone().projectOnPlane((0, $06989a4a8159123e$export$60bbd10bdffb2e81).j);\n        const curve = new (0, $ilwiq.EllipseCurve)(this.origin.x, this.origin.y, radius, radius, 0, this.target.angleTo(projectedVector), false, 0);\n        const material = new (0, $ilwiq.LineBasicMaterial)({\n            color: 0x000000\n        });\n        const geometry = new (0, $ilwiq.BufferGeometry)().setFromPoints(curve.getPoints(50));\n        geometry.applyQuaternion(new (0, $ilwiq.Quaternion)().setFromAxisAngle((0, $06989a4a8159123e$export$60bbd10bdffb2e81).j, -(0, $06989a4a8159123e$export$60bbd10bdffb2e81).i.angleTo(projectedVector)));\n        return new (0, $ilwiq.Line)(geometry, material);\n    }\n    createProjection(plane) {\n        const lineMaterial = new (0, $ilwiq.LineDashedMaterial)({\n            color: 0x000000,\n            linewidth: 1,\n            scale: 1,\n            dashSize: 0.25,\n            gapSize: 0.1\n        });\n        const planeNormal = (0, $06989a4a8159123e$export$bb7594b552f278d7)[plane].normal;\n        const projectedVector = this.target.clone().projectOnPlane(planeNormal);\n        const projectionGeometry = new (0, $ilwiq.BufferGeometry)().setFromPoints([\n            projectedVector,\n            this.origin\n        ]);\n        const connectionGeometry = new (0, $ilwiq.BufferGeometry)().setFromPoints([\n            projectedVector,\n            this.target\n        ]);\n        return [\n            new (0, $ilwiq.Line)(projectionGeometry, lineMaterial).computeLineDistances(),\n            new (0, $ilwiq.Line)(connectionGeometry, lineMaterial).computeLineDistances()\n        ];\n    }\n    getFrameable() {\n        return this.drawables;\n    }\n}\n\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nconst $9a8cebc34540b0c1$export$158a78f343a14874 = (n = 100, scale = 10)=>{\n    const points = [];\n    for(let index = 0; index < n; index++){\n        const x = Math.random() * scale;\n        const y = Math.random() * scale;\n        const z = Math.random() * scale;\n        points.push(new (0, $ilwiq.Vector3)(x, y, z));\n    }\n    return points;\n};\n\n\n\n\n//# sourceMappingURL=index.53383873.js.map\n","export { Frame } from \"./frame\";\nexport { ScatterPlot } from \"./scatterplot\";\nexport { VectorPlot } from \"./vectorplot\";\nexport { getRandomPoints } from \"./data\";\n","import {\n  AxesHelper,\n  Color,\n  GridHelper,\n  PerspectiveCamera,\n  Scene,\n  Vector3,\n  WebGLRenderer,\n} from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport { Axes } from \"./axes\";\nimport { Plot } from \"./plot\";\n\nexport class Frame extends Scene {\n  protected scene: Scene;\n  protected renderer: WebGLRenderer;\n  protected camera: PerspectiveCamera;\n  protected axes: Axes;\n  protected controls: OrbitControls;\n  protected observer: ResizeObserver = new ResizeObserver(() => this.update());\n\n  // TODO: at the moment only one size bc grid can only be squared\n  // look into this for solution https://discourse.threejs.org/t/rectangular-gridhelper-possibility/37812\n  constructor(\n    protected canvas: HTMLCanvasElement,\n    protected size = 10\n  ) {\n    super();\n    this.scene = new Scene();\n    this.scene.background = new Color(0xffffff);\n\n    const { clientWidth, clientHeight } = canvas;\n\n    this.renderer = new WebGLRenderer({ canvas });\n    this.renderer.setSize(clientWidth, clientHeight);\n\n    this.setCamera(clientWidth, clientHeight);\n    this.setControls();\n    this.setAxes();\n\n    this.updateOnChanges();\n    this.update();\n  }\n\n  private setCamera(width: number, height: number) {\n    this.camera = new PerspectiveCamera(45, width / height, 0.1, 1000);\n    this.camera.position.set(this.size * 2, this.size * 2, this.size * 2);\n    this.scene.add(this.camera);\n  }\n\n  private setControls() {\n    this.controls = new OrbitControls(this.camera, this.canvas);\n    this.controls.target.set(0, 0, 0);\n  }\n\n  private setAxes() {\n    this.axes = new Axes(this.size, this.size, this.size);\n\n    this.scene.add(this.axes.x);\n    this.scene.add(this.axes.y);\n    this.scene.add(this.axes.z);\n\n    this.scene.add(this.axes.gridXY);\n    this.scene.add(this.axes.gridXZ);\n    this.scene.add(this.axes.gridYZ);\n  }\n\n  updateOnChanges() {\n    this.controls.addEventListener(\"change\", () => this.update());\n    this.observer.observe(this.canvas);\n  }\n\n  protected update() {\n    this.renderer.render(this.scene, this.camera);\n  }\n\n  public capture() {\n    const base64 = this.canvas.toDataURL(\"img/png\");\n  }\n\n  public addPlot(plot: Plot) {\n    this.scene.add(...plot.getFrameable())\n    this.update();\n  }\n}\n","import { ArrowHelper, GridHelper, Vector3 } from \"three\";\n\nexport const UnitVector = {\n  i: new Vector3(1, 0, 0),\n  j: new Vector3(0, 1, 0),\n  k: new Vector3(0, 0, 1),\n} as const;\n\nexport const AxesPlane = {\n  xy: { normal: UnitVector.k, unit: { x: UnitVector.i, y: UnitVector.j } },\n  xz: { normal: UnitVector.j, unit: { x: UnitVector.i, z: UnitVector.k } },\n  yz: { normal: UnitVector.i, unit: { y: UnitVector.j, z: UnitVector.k } },\n} as const;\n\nclass Axis extends ArrowHelper {\n  constructor(direction: Vector3, length: number) {\n    super(direction, new Vector3(0, 0, 0), length);\n  }\n}\n\nexport class Axes {\n  public x: Axis;\n  public y: Axis;\n  public z: Axis;\n  public gridXZ: GridHelper;\n  public gridXY: GridHelper;\n  public gridYZ: GridHelper;\n\n  constructor(\n    private lengthX: number,\n    private lengthY: number,\n    private lengthZ: number\n  ) {\n    this.x = new Axis(new Vector3(1, 0, 0), this.lengthX * 1.1);\n    this.y = new Axis(new Vector3(0, 1, 0), this.lengthY * 1.1);\n    this.z = new Axis(new Vector3(0, 0, 1), this.lengthZ * 1.1);\n\n    this.setGrids();\n  }\n\n  private setGrids() {\n    this.gridXZ = new GridHelper(Math.max(this.lengthX, this.lengthZ));\n    this.gridXZ.position.setX(this.lengthX / 2);\n    this.gridXZ.position.setZ(this.lengthZ / 2);\n\n    this.gridXY = new GridHelper(Math.max(this.lengthX, this.lengthY));\n    this.gridXY.position.setX(this.lengthX / 2);\n    this.gridXY.position.setY(this.lengthY / 2);\n    this.gridXY.rotateOnAxis(new Vector3(1, 0, 0), Math.PI / 2);\n\n    this.gridYZ = new GridHelper(Math.max(this.lengthY, this.lengthZ));\n    this.gridYZ.position.setY(this.lengthY / 2);\n    this.gridYZ.position.setZ(this.lengthZ / 2);\n    this.gridYZ.rotateOnAxis(new Vector3(0, 0, 1), Math.PI / 2);\n  }\n}\n","import { Mesh, MeshBasicMaterial, SphereGeometry, Vector3 } from \"three\";\nimport { Plot } from \"./plot\";\n\nexport class ScatterPlot extends Plot {\n  points: Mesh[];\n\n  constructor(points: Vector3[], pointRadius = 0.2) {\n    super();\n\n    this.points = points.map((v) => {\n      const geometry = new SphereGeometry(pointRadius);\n      const material = new MeshBasicMaterial({ color: 0x00ff00 });\n      const obj = new Mesh(geometry, material);\n      obj.position.set(v.x, v.y, v.z);\n      return obj;\n    });\n  }\n\n  getFrameable() {\n    return this.points;\n  }\n}\n","import { Object3D } from \"three\";\n\ninterface FramedObject {\n  getFrameable(): Object3D[];\n}\n\nexport abstract class Plot implements FramedObject {\n  abstract getFrameable(): Object3D[];\n}\n","import {\n  ArrowHelper,\n  BufferGeometry,\n  EllipseCurve,\n  Line,\n  LineBasicMaterial,\n  LineDashedMaterial,\n  Object3D,\n  Object3DEventMap,\n  Quaternion,\n  Vector3,\n} from \"three\";\nimport { Plot } from \"./plot\";\nimport { AxesPlane, UnitVector } from \"./axes\";\n\nexport class VectorPlot extends Plot {\n  private drawables: (ArrowHelper | Line)[];\n\n  constructor(private origin: Vector3, private target: Vector3) {\n    super();\n\n    this.drawables = [];\n\n    this.drawables.push(this.createVector(origin, target));\n    this.drawables.push(...this.createProjection(\"xy\"));\n    this.drawables.push(...this.createProjection(\"yz\"));\n    this.drawables.push(...this.createProjection(\"xz\"));\n    this.drawables.push(this.createAngleToProjection(\"xz\"));\n    this.drawables.push(this.createAngleToProjection(\"xy\"));\n    this.drawables.push(this.createAngleToProjection(\"yz\"));\n    this.drawables.push(this.createAngleToTarget(\"y\"));\n  }\n\n  private createVector(origin: Vector3, target: Vector3) {\n    const length = Math.abs(origin.distanceTo(target));\n\n    return new ArrowHelper(\n      target.clone().normalize(),\n      origin,\n      length,\n      0x000000,\n      length * 0.2,\n      length * 0.1\n    );\n  }\n\n  private createAngleToProjection<P extends keyof typeof AxesPlane>(\n    planeIdx: P\n  ) {\n    const plane = AxesPlane[planeIdx];\n    const planeNormal = plane.normal;\n    const projectedVector = this.target.clone().projectOnPlane(planeNormal);\n    const radius = projectedVector.distanceTo(this.origin) * 0.5;\n\n    let initialRotation = 0;\n    let angleToProjection = projectedVector.angleTo(UnitVector.i);\n\n    if (planeIdx === \"xz\") {\n      initialRotation = -Math.PI / 2;\n      angleToProjection = projectedVector.angleTo(UnitVector.k);\n    }\n\n    if (planeIdx === \"yz\") {\n      initialRotation = Math.PI / 2;\n      angleToProjection = projectedVector.angleTo(UnitVector.j);\n    }\n\n    const curve = new EllipseCurve(\n      this.origin.x,\n      this.origin.y,\n      radius,\n      radius,\n      0,\n      angleToProjection,\n      false,\n      initialRotation\n    );\n\n    const material = new LineBasicMaterial({ color: 0x000000 });\n    const geometry = new BufferGeometry().setFromPoints(curve.getPoints(50));\n\n    const rotation = new Quaternion().setFromUnitVectors(\n      UnitVector.k,\n      plane.normal\n    );\n\n    geometry.applyQuaternion(rotation);\n\n    return new Line(geometry, material);\n  }\n\n  private createAngleToTarget(axis: \"x\" | \"y\" | \"z\") {\n    const radius = this.target.clone().distanceTo(this.origin);\n\n    const projectedVector = this.target.clone().projectOnPlane(UnitVector.j);\n\n    const curve = new EllipseCurve(\n      this.origin.x,\n      this.origin.y,\n      radius,\n      radius,\n      0,\n      this.target.angleTo(projectedVector),\n      false,\n      0\n    );\n\n    const material = new LineBasicMaterial({ color: 0x000000 });\n    const geometry = new BufferGeometry().setFromPoints(curve.getPoints(50));\n    geometry.applyQuaternion(\n      new Quaternion().setFromAxisAngle(\n        UnitVector.j,\n        -UnitVector.i.angleTo(projectedVector)\n      )\n    );\n\n    return new Line(geometry, material);\n  }\n\n  private createProjection<P extends keyof typeof AxesPlane>(plane: P) {\n    const lineMaterial = new LineDashedMaterial({\n      color: 0x000000,\n      linewidth: 1,\n      scale: 1,\n      dashSize: 0.25,\n      gapSize: 0.1,\n    });\n\n    const planeNormal = AxesPlane[plane].normal;\n\n    const projectedVector = this.target.clone().projectOnPlane(planeNormal);\n\n    const projectionGeometry = new BufferGeometry().setFromPoints([\n      projectedVector,\n      this.origin,\n    ]);\n\n    const connectionGeometry = new BufferGeometry().setFromPoints([\n      projectedVector,\n      this.target,\n    ]);\n\n    return [\n      new Line(projectionGeometry, lineMaterial).computeLineDistances(),\n      new Line(connectionGeometry, lineMaterial).computeLineDistances(),\n    ];\n  }\n\n  public getFrameable(): Object3D<Object3DEventMap>[] {\n    return this.drawables;\n  }\n}\n","import { Vector3 } from \"three\";\n\nexport const getRandomPoints = (n = 100, scale = 10): Vector3[] => {\n  const points: Vector3[] = [];\n  for (let index = 0; index < n; index++) {\n    const x = Math.random() * scale;\n    const y = Math.random() * scale;\n    const z = Math.random() * scale;\n\n    points.push(new Vector3(x, y, z));\n  }\n\n  return points;\n};\n"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$ilwiq","$06989a4a8159123e$export$60bbd10bdffb2e81","i","Vector3","j","k"],"version":3,"file":"index.53383873.js.map"}